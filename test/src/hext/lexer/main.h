#ifndef HEXT_LEXER_MAIN_H
#define HEXT_LEXER_MAIN_H

#include <cstring>

#include "gtest/gtest.h"

// lexer.h is generated by ragel. 
// If missing, call /scripts/run_ragel.sh [project root]
#include "hext/lexer.h"
#include "hext/token.h"


namespace {


std::vector<hext::token> lex_str(const char * s)
{
  const char * se = s + strlen(s);
  hext::lexer l(s, se);
  return l.lex();
}


TEST(HextLexerTest, EmptyRule)
{
  auto tokens = lex_str("<>");
  EXPECT_EQ(tokens.size(), 2);
  EXPECT_EQ(tokens.front().tid, hext::TK_RULE_BEGIN);
  EXPECT_EQ(tokens.back().tid,  hext::TK_RULE_END);

  tokens = lex_str("< >");
  EXPECT_EQ(tokens.size(), 2);
  EXPECT_EQ(tokens.front().tid, hext::TK_RULE_BEGIN);
  EXPECT_EQ(tokens.back().tid,  hext::TK_RULE_END);

  tokens = lex_str("< >\n");
  EXPECT_EQ(tokens.size(), 2);
  EXPECT_EQ(tokens.front().tid, hext::TK_RULE_BEGIN);
  EXPECT_EQ(tokens.back().tid,  hext::TK_RULE_END);

//  tokens = lex_str("< >\n\n");
//  EXPECT_EQ(tokens.size(), 2);
//  EXPECT_EQ(tokens.front().tid, hext::TK_RULE_BEGIN);
//  EXPECT_EQ(tokens.back().tid,  hext::TK_RULE_END);
}

TEST(HextLexerTest, ErroneousRule)
{
  const char * errors[] = {
    /* nonsense input */
    "<", ">", "!<", "a!", "!a",
    "<asd", "<asd asd", "<*asd",
    "*<asd", ">*", "<\"\">", "<>a",
    "<> a", "a <a>",
    /* probable input */
    "<0>", "<01>", "<0asd>",
    "<*!asd>", "<a href=>", 
    "<a href=\">", "<@>",
    "<a href=\" \">",
    "<a href=\"a a\">",
    "<a href=\"(:cap\">",
    "<a href=\"(: )\">",
    "<a href=\"(:a a)\">"
  };

  for(const char * s : errors)
  {
    EXPECT_THROW(lex_str(s), hext::lexer::lex_error)
      << "s: \"" << s << "\"";
  }
}


} // namespace


#endif // HEXT_LEXER_MAIN_H

